<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Charlie Wiebe &amp; Hakeem Salami">

<title>Machine Learning for Natural Product Discovery</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="capstone_paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="capstone_paper_files/libs/quarto-html/quarto.js"></script>
<script src="capstone_paper_files/libs/quarto-html/popper.min.js"></script>
<script src="capstone_paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="capstone_paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="capstone_paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="capstone_paper_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="capstone_paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="capstone_paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="capstone_paper_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="capstone_paper.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Machine Learning for Natural Product Discovery</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Charlie Wiebe &amp; Hakeem Salami </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p><strong>Introduction</strong></p>
<p>Earth is estimated to harbor between 2.2 and 3.8 million fungal species, with some estimates extending to 5 million (Hawksworth &amp; Lücking, 2017). Yet, only ~148,000 fungal species have been formally described, and even fewer have fully sequenced, publicly available genomes. This vast unexplored diversity is an untapped resource for natural product discovery, given the central role of fungi in producing bioactive small molecules such as Penicillin (antibiotic), Cyclosporin A (immunosuppressant), and Lovastatin (cholesterol-lowering agent). These compounds, encoded by biosynthetic gene clusters (BGCs), have transformed medicine, agriculture, and biotechnology.</p>
<p>Despite their promise, fungal BGC discovery lags far behind bacterial BGC research. Challenges include larger and more repetitive genomes, complex gene regulation, sparse labeling of fungal BGCs, and the absence of fungal-specific prediction workflows. Current tools such as antiSMASH and DeepBGC, which are designed primarily for bacteria, often underperform on fungi. There is no streamlined, reproducible pipeline that can take a newly sequenced fungal genome (from research labs or citizen scientists) and generate high-confidence BGC predictions ready for drug discovery triage.</p>
<p>This capstone addresses that gap by developing a fungal-specific machine learning pipeline that links raw genome assemblies to BGC predictions in a workflow. The approach requires little manual reconfiguration beyond basic quality control and is designed to democratize fungal natural product discovery for both professional scientists and amateur mycologists.</p>
<p>Beyond prediction, we explore ecological drivers of BGC diversity, testing whether certain environmental niches are enriched for specific BGC classes or higher overall BGC richness. These insights can guide targeted sampling in ecosystems with the greatest potential for chemically novel metabolites.</p>
<p><strong>Data Engineering</strong></p>
<p>The success of this project depended on assembling three distinct but interlinked data resources: reference BGCs from curated repositories, whole-genome assemblies and annotations from publicly available fungal sequencing efforts, and ecological context data derived from geo-referenced observations and environmental variables. Each dataset required custom ingestion pipelines, specific filtering and cleaning steps, and final organization into a standardized storage architecture to support reproducible downstream analysis.</p>
<p>For reference BGC data, we downloaded all biosynthetic gene cluster files from the Minimum Information about a Biosynthetic Gene cluster (MIBiG) repository, which included both GenBank (.gbk) sequence files and associated metadata in JSON format. Because the majority of BGCs in MIBiG are derived from bacteria and archaea, we implemented a custom filtering workflow to isolate fungal-only clusters. This step used a LangChain wrapper connected to the GPT‑3.5‑turbo API to evaluate organism metadata (species name, taxonomy fields, and literature references) and classify whether the source organism was fungal. Only entries with clear fungal origin were retained, resulting in a curated collection of ~500 high-confidence fungal BGC snippets used as positive training examples and for downstream modeling. All retained entries were indexed by accession ID and stored locally, preserving original metadata for reference.</p>
<p>Approximately 200 whole-genome fungal assemblies and annotations were obtained from the Joint Genome Institute (JGI) MycoCosm portal. Because the JGI interface is built on a JavaServer Faces (JSF) framework and does not expose static download links, we implemented a custom scraper that interacted directly with the JGI Search and Download APIs. The scraper authenticated using session cookies and iteratively queried the search API for fungal projects. For each organism, files were filtered using prioritized suffix matching to identify genome assemblies (.fna or .fasta), protein sequences (.faa), and gene annotation files (.gff). Organisms containing all three file types were classified as “full-featured,” while those with assemblies only were labeled “predictive-only.” All results were logged in JSON manifests to ensure reproducibility and progress tracking. Download requests were then submitted through the JGI download API, which allowed automated recovery of files even when some had been archived, by submitting restore requests programmatically. All downloaded files were saved in a standardized folder hierarchy, extracted, and renamed to follow a consistent format (e.g., SpeciesName_proteins.faa). This structure provided reliable and unambiguous access to genomes and annotations during model training and testing.</p>
<p>To integrate ecological context, we collected geo-referenced fungal observation data from the iNaturalist API. Species names were resolved to their taxonomic identifiers to ensure correct species-level matching, and observations were filtered to retain only valid latitude and longitude coordinates. Additionally, the species classifications had to have been verified by at least two community contributors to be included in our dataset. The observational coordinates were then used to extract environmental variables, including temperature, precipitation, solar radiation (all from the WorldClim v2.1 dataset), and elevation, sampled using Rasterio. This produced an enriched table linking species observations to climatic and topographic conditions, resulting in a dataset of fungal occurrences annotated with both geographic and environmental variables.</p>
<p>All resulting datasets were organized into a species-centric directory structure, with each genome stored in its own folder containing the assembly, protein, and gene files; BGC reference snippets organized by accession; ecological data stored as CSV tables; and JSON manifests tracking file provenance and classification. This standardized storage approach enables fully automated genome-to-BGC prediction workflows and ecological enrichment analyses. Together, these integrated data resources provide the foundation for building and testing a fungal-specific machine learning pipeline for BGC discovery and for evaluating the ecological factors associated with BGC diversity.</p>
<p><strong>Machine Learning</strong></p>
<p>Protein-coding sequences from each genome were scanned with hmmscan (HMMER) against the Pfam-A database, producing domain annotations for each protein. These were aggregated into a binary presence/absence matrix of 1,671 unique Pfam domains. Each row represented a genomic region; columns indicated domain presence. The training set consisted of ~338 genomic sequences containing BGC and non-BGC windows, with 162 genomic sequences reserved for testing. On average, genomes contained 6-12 BGCs (median = 8). We trained a random forest classifier– for its robustness to high-dimensional sparse features (in this case, sparsity refers to how rarely BGCs are found in genomes), interpretability, and ability to model non-linear co-occurrence patterns of domains.</p>
<p>Our random forest model performed exceptionally well compared to historic baselines pulled from literature. The model’s overall accuracy was 0.982, and had a ROC-AUC of 0.972 (published fungal ROC-AUCs for DeepBGC were typically between 0.88 and 0.92), and a PR-AUC of 0.958. The model’s conservative bias makes it well-suited for triaging candidates where false positives are costly.</p>
<p><strong>Ecological Analysis</strong></p>
<p>We defined BGC richness as the count of distinct BGC classes (0–10) per observation and modeled richness using a Negative Binomial GLM after confirming overdispersion (Pearson χ²/df ≈ 1.61). Class-specific presence/absence was modeled with logistic regression, and we applied Benjamini–Hochberg false discovery rate control (q &lt; 0.05) separately for each predictor. To aid interpretability, all ecological predictors were standardized, and figures paired the fitted relationships with the underlying points to show variance and clustering.</p>
<p>In the richness models, precipitation was positively associated with BGC richness (IRR = 1.21; ~21% increase per +1 SD; 95% CI ≈ 1.05–1.40), whereas temperature showed a negative association (IRR = 0.86; ~14% decrease per +1 SD). Elevation (IRR = 0.95; ~5% decrease) and solar radiation (IRR = 1.03; ~3% increase) exhibited comparatively small effects. Plots included both model fit lines and individual observations to illustrate the dispersion of points around the fitted trends.</p>
<p>Class-specific analyses revealed that meroterpenoid-like and RiPP clusters displayed extreme versions of the precipitation and temperature patterns seen in the richness models (precipitation OR ≈ 12; temperature OR ≈ 0.11–0.10; all q &lt; 0.05). When we excluded observations containing either meroterpenoid-like or RiPP clusters and re-fit the richness models, the precipitation and temperature effects were no longer significant, indicating that the overall richness–environment signal was largely driven by these two classes. In contrast, siderophores showed the opposite ecological pattern, with higher odds at increased temperature and elevation and lower odds with greater precipitation and solar radiation.</p>
<p><strong>Figures</strong></p>
<p>Figure 1. BGC richness vs temperature (Negative Binomial model fits; individual points shown; shaded = 95% CI) <img src="fig1.png" class="img-fluid" alt="Figure 1. BGC richness vs temperature (Negative Binomial model fits; individual points shown; shaded = 95% CI)"></p>
<p>Figure 2. BGC richness vs precipitation (Negative Binomial model fits; individual points shown; shaded = 95% CI) <img src="fig2.png" class="img-fluid" alt="Figure 2. BGC richness vs precipitation (Negative Binomial model fits; individual points shown; shaded = 95% CI)"></p>
<p>Figure 3. Heatmap of ORs by BGC class × environmental variable (q&lt;0.05 marked) <img src="fig3.png" class="img-fluid" alt="Figure 3. Heatmap of ORs by BGC class × environmental variable (q<0.05 marked)"></p>
<p><strong>Data Ethics</strong></p>
<p>All datasets (MIBiG, JGI MycoCosm, iNaturalist) were used under stated terms. No personally identifiable information from iNaturalist was stored. Access tokens and cookies were kept outside the codebase.</p>
<p>We did not adjust for uneven observation density across ecological regions, which is a limitation that could bias results toward habitats where observers are more active. Future work should incorporate per-capita measures or sampling-effort offsets in models.</p>
<p>All scripts were logged, versioned, and reproducible. LLMs were used only for metadata triage of MIBiG entries, with human review, and LLM calls were batched in order to limit environmental impact.</p>
<p><strong>Conclusion</strong></p>
<p>We deliver an end-to-end fungal BGC prediction pipeline that outperforms bacterial-tuned baselines and enables ecological context analysis. Overall BGC richness is difficult to predict from environmental predictors alone; however, specific classes– particularly meroterpenoid-like and RiPP clusters– exhibit strong and consistent associations with precipitation and temperature. When fungi containing these two classes are excluded, the richness-environment relationships largely disappear, indicating that the aggregate richness signal is driven primarily by these categories.</p>
<p>Ecologically, meroterpenoid-like and RiPP clusters are enriched in wet, low-temperature settings, suggesting that sampling in moist microhabitats during wet seasons will maximize recovery of these chemistries, whereas siderophores align with drier, higher-elevation environments, guiding targeted searches for iron-scavenging pathways. These patterns provide practical guidance for concentrating drug-discovery efforts in ecosystems most likely to yield chemically novel metabolites, underscoring the societal and medical value of exploring fungal BGC diversity.</p>
<p>Future work should expand curated fungal BGC labels, incorporate synteny and sequence-context features via deep learning, adjust ecological models for uneven observation density, validate predictions with metabolomics, and release an open, citizen-science-friendly workflow.</p>
<p><strong>Works Cited</strong></p>
<p>Hawksworth, D. L., &amp; Lücking, R. (2017). Fungal diversity revisited: 2.2 to 3.8 million species. Microbiology Spectrum, 5(4), FUNK-0052-2016. https://doi.org/10.1128/microbiolspec.FUNK-0052-2016</p>
<p>Hannigan, G. D., Prihoda, D., Palicka, A., Soukup, J., Klempir, O., Rampula, L., Durcak, J., Wurst, M., Kotowski, J., Chang, D., Wang, R., Piizzi, G., Temesi, G., Hazuda, D. J., Woelk, C. H., &amp; Bitton, D. A. (2019). A deep learning genome-mining strategy for biosynthetic gene cluster prediction. Nucleic Acids Research, 47(18), e110. https://doi.org/10.1093/nar/gkz654</p>
<p>Fick, S. E., &amp; Hijmans, R. J. (2017). WorldClim 2: New 1-km spatial resolution climate surfaces for global land areas. International Journal of Climatology, 37(12), 4302–4315. https://doi.org/10.1002/joc.5086</p>
<p>Grigoriev, I. V., Nikitin, R., Haridas, S., Kuo, A., Ohm, R. A., Mondo, S. J., Salamov, A. A., Zimmerman, A., Korzeniewski, F., Smirnova, T., Nordberg, H., Dubchak, I., &amp; Shabalov, I. (2014). MycoCosm portal: Gearing up for 1000 fungal genomes. Nucleic Acids Research, 42(D1), D699–D704. https://doi.org/10.1093/nar/gkt1183</p>
<p>Kautsar, S. A., van der Hooft, J. J. J., de Ridder, D., &amp; Medema, M. H. (2020). MIBiG 2.0: A repository for biosynthetic gene clusters of known function. Nucleic Acids Research, 48(D1), D454–D458. https://doi.org/10.1093/nar/gkz882</p>
<p>Di Cecco, G. J., Barve, V., Belitz, M. W., Stucky, B. J., Guralnick, R. P., &amp; Hurlbert, A. H. (2021). Observing the observers: How participants contribute data to iNaturalist and implications for biodiversity science. BioScience, 71(11), 1179–1188. https://doi.org/10.1093/biosci/biab093</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>